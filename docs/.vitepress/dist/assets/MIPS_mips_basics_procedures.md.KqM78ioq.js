import{_ as s,a as i,b as a}from"./chunks/mips2-image-0009.DsZdjqOc.js";import{_ as n,c as e,o as t,a4 as l}from"./chunks/framework.DRnJpP2i.js";const f=JSON.parse('{"title":"MIPS Basics and Procedures","description":"","frontmatter":{},"headers":[],"relativePath":"MIPS/mips_basics&procedures.md","filePath":"MIPS/mips_basics&procedures.md"}'),p={name:"MIPS/mips_basics&procedures.md"},h=l(`<h1 id="mips-basics-and-procedures" tabindex="-1"><strong>MIPS Basics and Procedures</strong> <a class="header-anchor" href="#mips-basics-and-procedures" aria-label="Permalink to &quot;**MIPS Basics and Procedures**&quot;">​</a></h1><h2 id="mips-basic-codes" tabindex="-1"><strong>MIPS Basic Codes</strong> <a class="header-anchor" href="#mips-basic-codes" aria-label="Permalink to &quot;**MIPS Basic Codes**&quot;">​</a></h2><h3 id="mips-code-for-if-statements" tabindex="-1"><strong>MIPS code for if statements</strong> <a class="header-anchor" href="#mips-code-for-if-statements" aria-label="Permalink to &quot;**MIPS code for if statements**&quot;">​</a></h3><ul><li>If the condition is an equality use beq, bne</li><li>If the condition is a comparison combine beq/ bne with set-on-less-than</li></ul><p><strong>Why not blt or bge?</strong> While blt and bge (pseudo-instructions) are available in MIPS, beq and bne are favoured inconditional statements for their efficiency making them the common choice.</p><p><strong>Example 1)</strong> Given,f:<code>$s0</code>, g:<code>$s1</code>, h:<code>$s2</code>, i:<code>$s3</code>, j:<code>$s4</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h;</span></span></code></pre></div><p><strong>Solution 1 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  bne $s3, $s4, else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $s0, $s1, $s2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  j endif</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">else:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sub</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $s0, $s1, $s2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">endif:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...........</span></span></code></pre></div><p><strong>Example 2)</strong> Given,f:$s0 ,g:$s1 ,h:$s2 ,i:$s3 ,j:$s4</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h;</span></span></code></pre></div><p><strong>Solution 2 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slt $to, $s3, $s4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  beq $to, $zero, else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $s0, $s1, $s2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  j endif</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">else:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  sub</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $s0, $s1, $s2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">endif:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .......</span></span></code></pre></div><h3 id="mips-code-for-loop-statements" tabindex="-1"><strong>MIPS code for Loop statements</strong> <a class="header-anchor" href="#mips-code-for-loop-statements" aria-label="Permalink to &quot;**MIPS code for Loop statements**&quot;">​</a></h3><p>Although there are said to be 3 different types of loops in C namely, do/while, while and for loop, they are all functionally identical. In other words, you can take any for-loop and easily turn it into a while-loop.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    loopbody;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>or</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  inti</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    loopbody;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p><strong>Example 1)</strong> Given, i:$s3, k:$s</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>Solution 1 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slt $t0, $s3, $s4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  beq $t0, $zero, exit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $s3, $s3, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exit:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...</span></span></code></pre></div><p><strong>Example 2)</strong> Given i:$t0, k is some integer</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // loop body</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p><strong>Solution 2 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $t0, $zero, $zero</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # i is initialized to 0, $t0 = 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: // </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $t0, $t0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # i ++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slti $t1, $t0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # $t1 = 1 if i &lt; 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  bne $t1, $zero, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Loop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # go to Loop if i &lt; 4</span></span></code></pre></div><p><strong>Example 3)</strong> Given, i:$s3, base address of arr:$s6, k:$s</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>Solution 3 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sll $t0, $s3, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $t1, $t0, $s6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lw $t2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($t1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  bne $t2, $s5, exit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $s3, $s3, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">loop</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exit:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span></code></pre></div><h2 id="procedures-in-mips" tabindex="-1"><strong>Procedures in MIPS</strong> <a class="header-anchor" href="#procedures-in-mips" aria-label="Permalink to &quot;**Procedures in MIPS**&quot;">​</a></h2><p>Understanding the memory layout and the way procedures are called is crucial for writing efficient and correct MIPS assembly code.</p><p>➢ Memory Layout</p><img src="`+s+'"><p>➢ Stack allocation (refer Recursion in MIPS(non-leaf procedure) for detailed explanation)</p><img src="'+i+'"><p>(a) before, (b) during, and (c) after a procedure call.</p><p>There are two types of procedure calling-</p><p><strong>1) Leaf Procedures:</strong> These procedures do not call other procedures.</p><p>When a leaf procedure is called:</p><p>● There turn address is saved on the stack. ● A stack frame/procedure frame/activation record is setup to store local variables. ● Arguments may be passed in registers or on the stack. ● The procedure executes its code.</p><p>Upon completion,it restores the stack pointer and returns to the saved return address.</p><p><strong>2) Non-leaf Procedures(NestedProcedures):</strong> These procedures call other procedures, eg.- <strong>Recursive Functions/Procedures.</strong></p><p>In addition to the steps for leaf procedures, non-leaf procedures must manage:</p><p>● Saving and restoring additional registers beyond there turn address. ● Managing multiple levels of procedure calls and returns. ● Ensuring that data in registers is preserved a cross nested calls. ● Properly handling there turn value from called procedures.</p><p>★ <strong>Function (Procedure) calling in MIPS</strong></p><p>In MIPS assembly language, passing parameters to functions involves using registers. Unlike high-level languages where parameters are often passed on the stack,MIPS typically uses specific registers for passing arguments.</p><p>● $a0 to $a3 :These are argument registers and are used to pass the first four arguments to a function. If a function has more than four parameters,additional parameters are typically passed on the stack.</p><p>● $v0 and $v1: These are value registers and are used to return values from functions. Functions can return up to two values using these registers.</p><img src="'+a+`"><p>(Note:-i) Register 1, called $at, is reserved for the assembler.<br> ii) Registers 26–27, called $k0–$k1 are reserved for the operating system.)</p><p>➢ <strong>Steps in calling a procedure (function)</strong></p><p>In MIPS assembly language, procedure calling follows a similar structure to function calls in high-level languages like C.</p><p>The following steps typically occur in both leaf and non-leaf functions but there are some nuances in how they&#39;re implemented, especially regarding the handling of the stack:</p><p>● <strong>Arguments Passing</strong> :.Arguments to the function can be passed via registers or the stack, depending on the calling convention. In register-based passing, arguments are loaded in to designated argument registers like $a0-$a3. If there are more arguments than available registers, excess arguments are typically passed on the stack.</p><p>● <strong>Jump and Link (jal)</strong> :jal makes the control jump to the given address while storing there turn address at PC+4 in the $ra register This effectively sets up the return mechanism for the function call.</p><p>● <strong>Function Prologue (Non-leaf functions):</strong> Non-leaf functions need to setup a stack frame. This involves: Saving the return address($ra) on to the stack, saving any callee- saved registers on to the stack(these are typically $s0-$s7),setting up the frame pointer($fp) to establish a reference point for accessing local variables and saved registers.</p><p>● <strong>Function Execution</strong> :The function performs its task, accessing arguments, local variables, and performing computations.</p><p><strong>● Function Epilogue (Non-leaf functions):</strong> Before returning, non-leaf functions need to cleanup the stack frame and restore the state of callee-saved registers.This involves restoring callee-saved registers from the stack, restoring the return address($ra) from the stack resetting the stack pointer($sp) to deallocate the stack frame, jumping back to the return address using the jr $ra instruction.</p><p>● Return: Upon completing its task, the function returns control to the caller. If it&#39;s a leaf function, it typically involves jumping back to the return address stored in $ra using the jr $ra instruction. For non-leaf functions, the return sequence includes restoring the stack frame and registers before jumping back to the caller.</p><p>(Note:-For simplicity we will only use $sp and extend the stack at procedure entry/exit)</p><p><strong>Example 1)</strong> Calling a procedure which prints a string</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span></code></pre></div><p><strong>Solution 1 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello_string:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .asciiz &quot;Hello, world!\\n&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # String definition</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.text</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">....previous code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jal printFunction #jump to printFunction</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addi $s2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">....further code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">li $v0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Set syscall code 10 for exit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">syscall</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Perform syscall to exit the program</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printFunction:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">li $v0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Set syscall code 4 to print a string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">la $a0, hello_string</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load the address of the string</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">syscall</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Perform syscall to print</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">jr $ra</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Return control to PC + 4</span></span></code></pre></div><p>● When jal is used, the control moves to the address specified in the instruction and the address of the next instruction is stored in $ra.</p><p>● When the procedure ends jr $ra is used to return control back to the next address from where it jumped.</p><p>● These procedures are usually placed after the “main” procedure to avoid instruction overlap.</p><p><strong>Example 1)</strong> Calling a function with parameters</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNumbers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span></code></pre></div><p><strong>Solution 1 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $a0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load first parameter (5) into $a0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $a1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load second parameter (7) into $a1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jal addNumbers</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Jump to addNumbers function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  move $s0, $v0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Store the result returned by addNumbers in $s0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Further code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $v0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Set syscall code 10 for exit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  syscall</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Perform syscall to exit the program</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addNumbers:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $v0, $a0, $a1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Add the values of $a0 and $a1 and store the result in $v0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jr $ra</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Return control to the next instruction after jal</span></span></code></pre></div><p>● In the main function, parameters are passed to the addNumbers function by loading values into registers $a0 and $a1.</p><p>● The jal instruction is used to jump to the addNumbers function.</p><p>● Inside the addNumbers function, the parameters are accessed from the $a0 and $a1 registers.</p><p>● The result of the addition is stored in register $v0, which is commonly used to return function results in MIPS.</p><p>● Finally, jr $ra is used to return control back to the instruction after the jal in the main function.</p><p>★ <strong>Recursion in MIPS (non-leaf procedure)</strong></p><p>In MIPS assembly language, implementing recursion involves understanding function calls and stack manipulation.</p><p><strong>The Stack in MIPS Assembly</strong></p><p>● The stack is a crucial data structure used in MIPS assembly language for managing function calls, local variables, and return addresses. ● It operates based on the Last-In-First-Out (LIFO) principle, meaning the last item pushed onto the stack is the first item to be popped off.</p><h3 id="stack-operations" tabindex="-1"><strong>Stack Operations:</strong> <a class="header-anchor" href="#stack-operations" aria-label="Permalink to &quot;**Stack Operations:**&quot;">​</a></h3><p><strong>Stack Pointer ($sp):</strong> ● The stack pointer register, $sp, points to the top of the stack. It keeps track of the current position in memory where new items are pushed onto or popped off the stack.</p><p><strong>Push Operation:</strong> ● To push data onto the stack, the stack pointer is decremented to reserve space for the new item, and then the data is stored at the memory location pointed to by the stack pointer.</p><p><strong>Pop Operation:</strong> ● To pop data off the stack,the data is retrieved from the memory location pointed to by the stack pointer, and then the stack pointer is incremented to remove the item from the stack.</p><p><strong>Stack Usage in Function Calls:</strong><strong>Function Prologue:</strong> ● When a function is called, the current contents of relevant registers (such as there turn address and callee-saved registers) are typically saved on the stack to ensure they are preserved. ● This process is often referred to as the function prologue.</p><p><strong>Function Epilogue:</strong> ● Upon completion of the function, the saved values on the stack are restored to their original registers. ● This process is known as the function epilogue.</p><p><strong>Example)</strong> Function Call and Stack Usage</p><p>● When main calls my Function using jal, the return address (the address of the instruction following the function call) is automatically saved in register $ra. ● Inside my Function, the function prologue allocates space on the stack to save the return address. ● The function body executes the desired operations. ● Finally, in the function epilogue, the return address is restored, and the stack space allocated in the prologue is deallocated before returning control to the caller.</p><p>To understand recursion in MIPS, a good understanding of the stack pointer and how it operates on memory is imperative. Recursion involves careful management of the function call stack, ensuring that return addresses and local variables are properly saved and restored. This example illustrates the process of calculating the factorial of a number using recursion in MIPS assembly language.</p><p><strong>Example) Calculating the factorial of a number using recursion</strong></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factorial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//code</span></span></code></pre></div><p><strong>Solution 1 :-</strong> Corresponding MIPS code</p><div class="language-asm vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $a0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load the value 5 (number whose factorial is to be calculated) into $a0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jal factorial</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Jump to the factorial function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  move $s0, $v0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Store the result returned by factorial in $s0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Further code using the result stored in $s0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $v0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Set syscall code 10 for exit</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  syscall</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Perform syscall to exit the program</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">factorial:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Function prologue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $sp, $sp, -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Allocate space on the stack for local variables</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sw $ra, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($sp)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Save the return address on the stack</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Check for base case: if n &lt;= 1, return 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $t0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load the value 1 into $t0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ble $a0, $t0, base_case</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Branch to base_case if $a0 (n) &lt;= $t0 (1)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Recursive case: n * factorial(n - 1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $a0, $a0, -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Decrement $a0 (n) by 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jal factorial</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Recursive call to factorial function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lw $ra, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($sp)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Restore the return address from the stack</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $sp, $sp, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Deallocate space on the stack for local variables</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $v0, $a0, $v0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Multiply n by the result of factorial(n - 1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jr $ra</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Return control to the caller</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base_case:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Base case: n &lt;= 1, return 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li $v0, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Load the value 1 into $v0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  lw $ra, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($sp)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Restore the return address from the stack</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  addi $sp, $sp, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Deallocate space on the stack for local variables</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  jr $ra</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # Return control to the caller</span></span></code></pre></div><p>● In the main function, the value 5 is loaded into register $a0 to calculate its factorial.<br> ● The factorial function is then called using the jal instruction.<br> ● Inside the factorial function, the base case checks if the input value n is less than or equal to 1.If so,it returns 1.<br> ● Otherwise,the function decrements n by 1 and recursively calls itself with the decremented value.<br> ● The result of the recursive call is then multiplied by n to compute the factorial. ● Finally,the result is returned to the caller using register $v0.</p><h3 id="references" tabindex="-1"><strong>References</strong> <a class="header-anchor" href="#references" aria-label="Permalink to &quot;**References**&quot;">​</a></h3><ul><li>J.L.Hennessy and D.A.Patterson Computer Organization and Design:The Hardware/Software Interface, Fifth Edition</li><li>“Digital Logic and Computer Design” by M.Morris Mano</li><li>“Digital Fundamentals” by Thomas L.Flyod</li><li><a href="http://www.cs.missouristate.edu/MARS/" target="_blank" rel="noreferrer">www.cs.missouristate.edu/MARS</a></li><li><a href="https://www.d.umn.edu/~gshute/mips/directives-registers.pdf" target="_blank" rel="noreferrer">https://www.d.umn.edu/~gshute/mips/directives-registers.pdf</a></li><li><a href="https://courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html" target="_blank" rel="noreferrer">courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html</a></li><li><a href="https://courses.missouristate.edu/KenVollmar/mars/Help/MarsHelpIntro.html" target="_blank" rel="noreferrer">courses.missouristate.edu/KenVollmar/mars/Help/MarsHelpIntro.html</a></li><li><a href="https://riptutorial.com/mips/example/29993/mars-mips-simulator" target="_blank" rel="noreferrer">riptutorial.com/mips/example/29993/mars-mips-simulator</a></li><li><a href="https://bytes.usc.edu/files/ee109/documents/MARS_Tutorial.pdf" target="_blank" rel="noreferrer">bytes.usc.edu/files/ee109/documents/MARS_Tutorial.pdf</a></li></ul>`,97),r=[h];function k(o,d,c,g,E,u){return t(),e("div",null,r)}const b=n(p,[["render",k]]);export{f as __pageData,b as default};
