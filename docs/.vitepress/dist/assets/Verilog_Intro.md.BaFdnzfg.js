import{_ as e,a as t,b as a,c as i,d as o,e as s,f as r,g as n,h as l,i as h,j as p,k as d,l as c,m as u,n as m,o as f,p as g,q as b,r as y,s as k,t as w,u as T,v as E,w as v,x as q,y as A,z as R,A as C,B as I,C as _,D,E as P,F as x,G as O,H as S,I as L,J as B,K as N,L as F,M as U,N as H,O as G,P as Y,Q as X,R as M,S as Q,T as W,U as j,V,W as K,X as J,Y as z,Z,$,a0 as ee,a1 as te,a2 as ae,a3 as ie,a4 as oe,a5 as se}from"./chunks/image-0179.B6sbhF8G.js";import{_ as re,c as ne,o as le,a4 as he}from"./chunks/framework.DRnJpP2i.js";const Ee=JSON.parse('{"title":"INTRODUCTION","description":"","frontmatter":{},"headers":[],"relativePath":"Verilog/Intro.md","filePath":"Verilog/Intro.md"}'),pe={name:"Verilog/Intro.md"},de=he(`<h1 id="introduction" tabindex="-1">INTRODUCTION <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;INTRODUCTION&quot;">​</a></h1><h2 id="table-of-contents" tabindex="-1">Table of Contents <a class="header-anchor" href="#table-of-contents" aria-label="Permalink to &quot;Table of Contents&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Topic</th><th>Page</th></tr></thead><tbody><tr><td>Introduction</td><td><a href="#introduction">1</a></td></tr><tr><td>Verilog Syntax</td><td><a href="#verilog-syntax">2</a></td></tr><tr><td>Basic Logic Gates</td><td><a href="#basic-logic-gates">3</a></td></tr><tr><td>Binary Adders and Subtractors</td><td><a href="#binary-adders-and-subtractors">4</a></td></tr><tr><td>Latches</td><td><a href="#latches">5</a></td></tr><tr><td>Flip Flops</td><td><a href="#flip-flops">6</a></td></tr><tr><td>Multiplexers</td><td><a href="#multiplexers">7</a></td></tr><tr><td>Demultiplexers</td><td><a href="#demultiplexers">8</a></td></tr><tr><td>Parity Generator</td><td><a href="#parity-generator">9</a></td></tr><tr><td>Code converter</td><td><a href="#code-converter">10</a></td></tr><tr><td>Comparators</td><td><a href="#comparators">11</a></td></tr><tr><td>Registers</td><td><a href="#registers">12</a></td></tr><tr><td>Counters</td><td><a href="#counters">13</a></td></tr><tr><td>Arithmetic Logic Unit</td><td><a href="#arithmetic-logic-unit-alu">14</a></td></tr><tr><td>Encoders</td><td><a href="#encoder">15</a></td></tr><tr><td>Decoders</td><td><a href="#decoder">16</a></td></tr><tr><td>How to make a verilog program</td><td><a href="#how-to-make-a-verilog-program">17</a></td></tr><tr><td>Bibliography</td><td><a href="#bibliography">18</a></td></tr></tbody></table><hr><p>Verilog is a <strong>Hardware Description Language (HDL)</strong>. They resemble programming languages specifically oriented to describe hardware structures and their behavior. This language describes an interconnection of components. Such a structural description, a netlist, can be used as input to logic simulation just as a schematic is used.</p><p>A typical procedure is used in employing an HDL description as simulation input. The steps in the procedure are analysis, elaboration, and initialization, followed by the simulation.<br> Analysis checks the description for violations of the syntax and semantic rules for the HDL and produces an intermediate representation of the design.</p><p>Elaboration traverses the design hierarchy represented by the description; in this process, the design hierarchy is flattened to an interconnection of modules described only by their behaviors.<br> The result of the analysis and elaboration performed by the compiler is a simulation model of the original HDL description. This model is then passed to the simulator for execution. Initialization sets all of the variables in the simulation model to specified or default values.<br> Simulation executes the simulation model in either batch or interactive mode with inputs specified by the user.</p><p>The testbench is a description that includes the design to be tested, typically referred to as the Device Under Test (DUT). The testbench describes a collection of hardware and software functions that apply inputs to the DUT and analyze the outputs for correctness.<br> Verilog supports a design at many levels of abstraction. The primary three kinds of abstraction in Verilog are</p><ul><li>Behavioral level</li><li>Register-transfer level</li><li>Gate level</li></ul><h3 id="behavioral" tabindex="-1">Behavioral: <a class="header-anchor" href="#behavioral" aria-label="Permalink to &quot;Behavioral:&quot;">​</a></h3><p>This is the highest level of abstraction provided by Verilog HDL. It describes the circuit using procedural statements (the &quot;always&quot; block, case, and if statements). At the behavioral level, the circuit is described using an algorithm consisting of a set of instructions executed one after the other sequentially.</p><h3 id="data-flow" tabindex="-1">Data-Flow: <a class="header-anchor" href="#data-flow" aria-label="Permalink to &quot;Data-Flow:&quot;">​</a></h3><p>This is the second highest level of abstraction. It specifies the circuit as a combination of operations and data transfer between the registers. In this approach, the &#39;assign&#39; statement is used. An assign statement is a continuous statement where any signal changes on the right-hand side will update the output signal. Changes in the inputs are continuously monitored. Any synthesizable code is called RTL code. Gate-Level: This is the lowest level of abstraction. Here, the circuit is described by logical links and their timing properties. The module is implemented in terms of logic gates and interconnections between these gates. It resembles a schematic drawing with components connected with signals.</p><h2 id="functional-differences" tabindex="-1">Functional Differences <a class="header-anchor" href="#functional-differences" aria-label="Permalink to &quot;Functional Differences&quot;">​</a></h2><h3 id="behavioral-level" tabindex="-1">Behavioral Level <a class="header-anchor" href="#behavioral-level" aria-label="Permalink to &quot;Behavioral Level&quot;">​</a></h3><h4 id="pros" tabindex="-1">Pros <a class="header-anchor" href="#pros" aria-label="Permalink to &quot;Pros&quot;">​</a></h4><ul><li>Easy to write and understand, especially for complex algorithms and high-level functionality.</li><li>Portability: the same behavioral code can be synthesized into different hardware architectures.</li><li>Enables early verification, allowing designers to test system functionality before committing to a particular hardware architecture.</li></ul><h4 id="cons" tabindex="-1">Cons <a class="header-anchor" href="#cons" aria-label="Permalink to &quot;Cons&quot;">​</a></h4><ul><li>Less control over the hardware implementation details.</li><li>Can be less efficient in terms of area, power, and performance than lower levels of abstraction.</li><li>More difficult to optimize for timing and power.</li></ul><h3 id="register-transfer-level-rtl" tabindex="-1">Register Transfer Level (RTL) <a class="header-anchor" href="#register-transfer-level-rtl" aria-label="Permalink to &quot;Register Transfer Level (RTL)&quot;">​</a></h3><h4 id="pros-1" tabindex="-1">Pros <a class="header-anchor" href="#pros-1" aria-label="Permalink to &quot;Pros&quot;">​</a></h4><ul><li>Offers greater control over the hardware implementation details.</li><li>Can be optimized for timing, power, and area, allowing for more efficient designs.</li><li>Can be used for both simulation and synthesis. Cons</li><li>More difficult to write and understand than the behavioral level.</li><li>Can be less portable than the behavioral level, since the same code may not synthesize correctly across different architectures.</li><li>Can be more difficult to verify than the behavioral level, since the design is more complex.</li></ul><h3 id="gate-level" tabindex="-1">Gate Level <a class="header-anchor" href="#gate-level" aria-label="Permalink to &quot;Gate Level&quot;">​</a></h3><h4 id="pros-2" tabindex="-1">Pros <a class="header-anchor" href="#pros-2" aria-label="Permalink to &quot;Pros&quot;">​</a></h4><ul><li>Provides the most detailed view of the hardware implementation.</li><li>Highly optimized for area, power, and performance.</li><li>Ideal for final verification of the design. Cons</li><li>Very difficult to write and understand.</li><li>Not portable: The code is specific to a particular hardware architecture.</li><li>Verification can be very time-consuming and difficult, especially for complex designs.</li></ul><hr><h2 id="verilog-syntax" tabindex="-1">VERILOG SYNTAX <a class="header-anchor" href="#verilog-syntax" aria-label="Permalink to &quot;VERILOG SYNTAX&quot;">​</a></h2><h4 id="code" tabindex="-1">CODE: <a class="header-anchor" href="#code" aria-label="Permalink to &quot;CODE:&quot;">​</a></h4><div class="language-v vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">v</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> half_adder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output s, c, input a, b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    assign s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    assign c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">endmodule</span></span></code></pre></div><p><code>module</code> is always terminated by <code>endmodule</code>. Always specify output first and then input.</p><h4 id="testbench" tabindex="-1">TESTBENCH: <a class="header-anchor" href="#testbench" aria-label="Permalink to &quot;TESTBENCH:&quot;">​</a></h4><div class="language-v vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">v</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> half_adder_test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    wire out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    half_adder </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,out</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ,in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reg [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    initial begin</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        begin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">        #20;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">endmodule</span></span></code></pre></div><p><code>reg</code>: store input values<br><code>wire</code>: store output values begin end is used to specify a block of code.</p><hr><h1 id="basic-logic-gates" tabindex="-1">BASIC LOGIC GATES <a class="header-anchor" href="#basic-logic-gates" aria-label="Permalink to &quot;BASIC LOGIC GATES&quot;">​</a></h1><p>Logic gates are basic building blocks of digital electronics circuits that perform logical operations on one or more binary inputs and produce a binary output. In other words, a logic gate is an electronic device that operates on logical signals (digital signals) to perform a Boolean function.</p><p>There are several types of logic gates, including:</p><p><code>AND</code> <strong>gate:</strong> It has two or more input signals and produces a HIGH output only if all inputs are HIGH. The AND gate symbol is the dot or multiplication symbol.</p><p><code>OR</code> <strong>gate:</strong> It has two or more input signals and produces a HIGH output if at least one input is HIGH. The OR gate symbol is the plus symbol.</p><p><code>NOT</code> gate (Inverter): It has one input signal and produces the complement of the input signal at its output. The NOT gate symbol is a triangle with a circle at the output.</p><p><code>NAND</code> <strong>gate:</strong> It is a combination of an AND gate and a NOT gate. It produces a LOW output only if all inputs are HIGH. The NAND gate symbol is an AND gate with a small circle at its output.</p><p><code>NOR</code> <strong>gate:</strong> It is a combination of an OR gate and a NOT gate. It produces a HIGH output only if all inputs are LOW. The NOR gate symbol is an OR gate with a small circle at its output.</p><p><code>XOR</code> <strong>gate:</strong> It has two input signals and produces a HIGH output if the two inputs are different (i.e., one input is HIGH and the other is LOW). The XOR gate symbol is the addition symbol with a circle around it.</p><p><code>XNOR</code> <strong>gate:</strong> It is a combination of an XOR gate and a NOT gate. It produces a HIGH output if the two inputs are the same (i.e., both inputs are HIGH or both inputs are LOW). The XNOR gate symbol is an XOR gate with a small circle at its output.</p><h2 id="binary-adders-and-subtractors" tabindex="-1">Binary Adders and Subtractors <a class="header-anchor" href="#binary-adders-and-subtractors" aria-label="Permalink to &quot;Binary Adders and Subtractors&quot;">​</a></h2><h3 id="half-adder" tabindex="-1">HALF ADDER <a class="header-anchor" href="#half-adder" aria-label="Permalink to &quot;HALF ADDER&quot;">​</a></h3><p>A half-adder is an arithmetic circuit that generates the sum of two binary digits. The circuit has two inputs and two outputs. The input variables are the augend and addend bits to be added, and the output variables produce the sum and carry.</p><p>The Boolean functions for the two outputs, easily obtained from the truth table, are</p><p>S = XY + XY = X ⊕ Y</p><p>C = XY</p><table tabindex="0"><thead><tr><th>x</th><th>y</th><th>C</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><img src="`+e+'" alt="img"></p><p><img src="'+t+'" alt="img"></p><h3 id="full-adder" tabindex="-1">FULL ADDER <a class="header-anchor" href="#full-adder" aria-label="Permalink to &quot;FULL ADDER&quot;">​</a></h3><p>A full adder is a combinational circuit that forms the arithmetic sum of three input bits. Two input variables, denoted by X and Y, represent the two significant bits to be added. The third input, Z, represents the carry from the previous lower significant position.<br> The simplified sum-of-product functions for the two outputs are :</p><p><img src="'+a+'" alt="img"></p><p><strong>S = XYZ + XYZ + XY Z + XYZ</strong><br><strong>C = XY + XZ + YZ</strong></p><p><img src="'+i+'" alt="img"></p><p>S = (X ⊕ Y) ⊕ Z</p><p>C = XY + Z(X ⊕ Y)</p><h3 id="ripple-carry-adder" tabindex="-1">RIPPLE CARRY ADDER <a class="header-anchor" href="#ripple-carry-adder" aria-label="Permalink to &quot;RIPPLE CARRY ADDER&quot;">​</a></h3><p>A parallel binary adder is a digital circuit that produces the arithmetic sum of two binary numbers using only combinational logic. The parallel adder uses n full adders in parallel, with all input bits applied simultaneously to produce the sum.<br> The full adders are connected in cascade, with the carry output from one full adder connected to the carry input of the next full adder. Since a 1 carry may appear near the least significant bit of the adder and yet propagate through many full adders to the most significant bit, just as a wave ripples outward from a pebble dropped in a pond, the parallel adder is referred to as a ripple carry adder.</p><h3 id="carry-look-ahead-adder" tabindex="-1">CARRY LOOK AHEAD ADDER <a class="header-anchor" href="#carry-look-ahead-adder" aria-label="Permalink to &quot;CARRY LOOK AHEAD ADDER&quot;">​</a></h3><p>Define two new binary variables</p><table tabindex="0"><thead><tr><th>Pi = Ai XOR Bi</th></tr></thead></table><table tabindex="0"><thead><tr><th>Gi = Ai AND Bi</th></tr></thead></table><p>the output sum and carry can respectively be expressed as</p><p><strong>Si = Pi XOR Ci</strong><br><strong>Ci+1 = Gi + (Pi AND Ci)</strong></p><p>Each sum output requires two exclusive-OR gates. The output of the first exclusive-OR gate generates the Pi variable, and the AND gate generates the Gi variable. The carries are propagated through the carry lookahead generator and applied as inputs to the second exclusive-OR gate. All output carries are generated after a delay through two levels of gates. Thus, outputs S1 through S3 have equal propagation delay times.</p><p><img src="'+o+'" alt="img"><img src="'+s+'" alt="img"></p><h3 id="half-subtractor" tabindex="-1">HALF SUBTRACTOR <a class="header-anchor" href="#half-subtractor" aria-label="Permalink to &quot;HALF SUBTRACTOR&quot;">​</a></h3><p>A half subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) and produces two output bits: the difference (D) and the borrow (B). The half subtractor is called &quot;half&quot; because it can only subtract two single-bit binary numbers, unlike a full subtractor that can subtract two multi-bit binary numbers. D= A XOR B B’ = Abar AND B</p><p><img src="'+r+'" alt="img"> <img src="'+n+'" alt="img"></p><h3 id="full-subtractor" tabindex="-1">FULL SUBTRACTOR <a class="header-anchor" href="#full-subtractor" aria-label="Permalink to &quot;FULL SUBTRACTOR&quot;">​</a></h3><p>A full subtractor is a combinational circuit that subtracts two single-bit binary numbers (A and B) along with a borrow (Bin) and produces two output bits: the difference (D) and the borrow (Bout). The full subtractor is an extension of the half subtractor, which can only subtract two single-bit binary numbers.</p><p>D = A XOR B XOR Bin<br> B’ = Abar AND B OR ((A XOR B)bar)Bin</p><p><img src="'+l+'" alt="img"><img src="'+h+'" alt="img"></p><h3 id="binary-adder-and-subtractor" tabindex="-1">BINARY ADDER AND SUBTRACTOR <a class="header-anchor" href="#binary-adder-and-subtractor" aria-label="Permalink to &quot;BINARY ADDER AND SUBTRACTOR&quot;">​</a></h3><p>M-N where M-minuend and N is subtrahend When performing a subtraction we complement the subtrahend N, and when performing an addition we do not complement N.</p><p>The 2s complement can be obtained by taking the 1s complement and adding 1 to the least significant bit. The 1s complement can be implemented easily with inverter circuits, and we can add 1 to the sum by making the input carry of the parallel adder equal to 1. The input carry C0 must be equal to 1. The operation that is performed becomes A plus the 1s complement of B plus 1. This is equal to A plus the 2s complement of B. For unsigned numbers, it gives A - B if A &gt;= B or the 2s complement of B - A if A []( B</p><p><img src="'+p+'" alt="img"></p><h2 id="latches" tabindex="-1">LATCHES <a class="header-anchor" href="#latches" aria-label="Permalink to &quot;LATCHES&quot;">​</a></h2><h3 id="sr-latch" tabindex="-1">SR LATCH <a class="header-anchor" href="#sr-latch" aria-label="Permalink to &quot;SR LATCH&quot;">​</a></h3><p>The SR latch is a circuit constructed from two cross- coupled NOR gates. The latch has two inputs, labeled S for set and R for reset, and two useful states. When output Q = 1 and Q = 0, the latch is said to be in the set state. When Q = 0 and Q = 1, it is in the reset state. Outputs Q and Q are normally the complements of each other. When both inputs are equal to 1 at the same time, an undefined state with both outputs equal to 0 occurs.</p><p><img src="'+d+'" alt="img"></p><h3 id="sr-latch-1" tabindex="-1">S̅R̅ LATCH <a class="header-anchor" href="#sr-latch-1" aria-label="Permalink to &quot;S̅R̅ LATCH&quot;">​</a></h3><p>The SR latch with two cross- coupled NAND gates. It operates with both inputs normally at 1, unless the state of the latch has to be changed. The application of a 0 to the S input causes output Q to go to 1, putting the latch in the set state. When the S input goes back to 1, the circuit remains in the set state. With both inputs at 1, the state of the latch is changed by placing a 0 on the R input. This causes the circuit to go to the reset state and stay there, even after both inputs return to 1. The condition that is undefined for this NAND latch is when both inputs are equal to 0 at the same time, an input combination that should be avoided. When the NAND latch requires a 0 signal to change its state, it is referred to as an SR latch.</p><p><img src="'+c+'" alt="img"></p><h3 id="sr-latch-with-control-input" tabindex="-1">SR LATCH WITH CONTROL INPUT <a class="header-anchor" href="#sr-latch-with-control-input" aria-label="Permalink to &quot;SR LATCH WITH CONTROL INPUT&quot;">​</a></h3><p>It consists of the basic NAND latch and two additional NAND gates. The control input C acts as an enable signal for the other two inputs. The output of the NAND gates stays at the logic- 1 level as long as the control input remains at 0.<br> When the control input goes to 1, information from the S and R inputs is allowed to affect the S R latch. The set state is reached with S = 1, R = 0, and C = 1. To change to the reset state, the inputs must be S = 0, R = 1, and C = 1. In either case, when C returns to 0, the circuit remains in its current state. Control input C = 0 disables the circuit so that the state of the output does not change, regardless of the values of S and R. Moreover, when C = 1 and both the S and R inputs are equal to 0, the state of the circuit does not change.An undefined state occurs when all three inputs are equal to 1. This condition places 0s on both inputs of the basic S R latch, giving an undefined state.</p><p><img src="'+u+'" alt="img"></p><h3 id="d-latch" tabindex="-1">D LATCH <a class="header-anchor" href="#d-latch" aria-label="Permalink to &quot;D LATCH&quot;">​</a></h3><p>One way to eliminate the undesirable undefined state in the SR latch is to ensure that inputs S and R are never equal to 1 at the same time. This is done in the D latch, shown in Figure 4-8. This latch has only two inputs: D (data) and C (control). The complement of the D input goes directly to the S input, and D is applied to the R input.<br> As long as the control input is 0, the S R latch has both inputs at the 1 level, and the circuit cannot change state regardless of the value of D. The D input is sampled when C = 1. If D is 1, the Q output goes to 1, placing the circuit in the set state. If D is 0, output Q goes to 0, placing the circuit in the reset state. The D latch receives its designation from its ability to hold data in its internal storage. The binary information present at the data input of the D latch is transferred to the Q output when the control input is enabled (1). The output follows changes in the data input, as long as the control input is enabled. When the control input is disabled (0), the binary information that was present at the data input at the time the transition in C occurred is retained at the Q output until the control input C is enabled again.</p><p><img src="'+m+'" alt="img"></p><h2 id="flip-flops" tabindex="-1">FLIP FLOPS <a class="header-anchor" href="#flip-flops" aria-label="Permalink to &quot;FLIP FLOPS&quot;">​</a></h2><p>There are basically 4 types of flip-flops:</p><ol><li>SR Flip-Flop</li><li>JK Flip-Flop</li><li>D Flip-Flop</li><li>T Flip-Flop</li></ol><h3 id="sr-flip-flop" tabindex="-1">SR FLIP-FLOP <a class="header-anchor" href="#sr-flip-flop" aria-label="Permalink to &quot;SR FLIP-FLOP&quot;">​</a></h3><p>SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with an enable signal. The circuit diagram of SR flip-flop is shown in the following figure.This circuit has two inputs S &amp; R and two outputs QN and Qn+1, present and next state respectively. The operation of the SR flip-flop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. Qn+1 = S + R’Qn</p><p><img src="'+f+'" alt="img"></p><h3 id="jk-flip-flop" tabindex="-1">JK FLIP-FLOP <a class="header-anchor" href="#jk-flip-flop" aria-label="Permalink to &quot;JK FLIP-FLOP&quot;">​</a></h3><p>JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has two inputs J &amp; K and two outputs Qn and Qn+1, present and next state respectively, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied.</p><p>Qn+1 = J(Qn)’ + K’(Qn)</p><p><img src="'+g+'" alt="img"></p><h3 id="d-flip-flop" tabindex="-1">D FLIP-FLOP <a class="header-anchor" href="#d-flip-flop" aria-label="Permalink to &quot;D FLIP-FLOP&quot;">​</a></h3><p>D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with an enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. This circuit has single input D and two outputs Qn and Qn+1. This flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable. D flip-flop always holds the information, which is available on data input, D of earlier positive transition of clock signal. Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal.</p><p>Qn+1 = D</p><p><img src="'+b+'" alt="img"></p><h3 id="t-flip-flop" tabindex="-1">T FLIP-FLOP <a class="header-anchor" href="#t-flip-flop" aria-label="Permalink to &quot;T FLIP-FLOP&quot;">​</a></h3><p>T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input ‘T’ to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. This circuit has single input T and two outputs Qn and Qn+1. The operation of the T flip-flop is the same as that of the JK flip-flop. Here, we considered the inputs of JK flip-flop as J = T and K = T in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, we eliminated the other two combinations of J &amp; K, for which those two values complement each other in a T flip-flop.</p><p>Qn+1 = T’Q(n) + (Q(n))’T = T XOR Q(n)</p><p><img src="'+y+'" alt="img"></p><h2 id="multiplexers" tabindex="-1">MULTIPLEXERS <a class="header-anchor" href="#multiplexers" aria-label="Permalink to &quot;MULTIPLEXERS&quot;">​</a></h2><h3 id="_2-1-mux" tabindex="-1">2-1 MUX <a class="header-anchor" href="#_2-1-mux" aria-label="Permalink to &quot;2-1 MUX&quot;">​</a></h3><p>It selects binary information from one of many input lines and directs the information to a single output line. The selection of a particular input line is controlled by a set of input variables, called selection inputs. there are 2^n input lines and n selection inputs whose bit combinations determine which input is selected. , if the select input S = 0, the output of the multiplexer takes on the values of I 0 , and, if input S = 1, the output of the multiplexer takes on the values of I 1 . Thus, S selects either input I 0 or input I 1 to appear at output Y.<br> We can see that the equation for the 2–to–1-line multiplexer output Y is<br> Y = S’I0 + SI1</p><p><img src="'+k+'" alt="img"></p><h3 id="_4-1-mux" tabindex="-1">4-1 MUX <a class="header-anchor" href="#_4-1-mux" aria-label="Permalink to &quot;4-1 MUX&quot;">​</a></h3><p>The function Y depends on four inputs I 0 , I 1 , I 2 , and I 3 and two select inputs S1 and S0 . By placing the values of I 0 through I 3 in the Y column. Since there are six variables, and only S1 and S0 are fixed, this single row represents 16 rows of the corresponding full truth table. From the table, we can write the equation for Y as<br> Y = S1’S0’ I0 + S1’S0 I1 + S1S0’I2 + S1S0 I3</p><table tabindex="0"><thead><tr><th>S1</th><th>S2</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>I0</td></tr><tr><td>0</td><td>1</td><td>I1</td></tr><tr><td>1</td><td>0</td><td>I2</td></tr><tr><td>1</td><td>1</td><td>I3</td></tr></tbody></table><p><img src="'+w+'" alt="img"></p><h2 id="demultiplexers" tabindex="-1">DEMULTIPLEXERS <a class="header-anchor" href="#demultiplexers" aria-label="Permalink to &quot;DEMULTIPLEXERS&quot;">​</a></h2><h3 id="_1-2-demux" tabindex="-1">1:2 DEMUX <a class="header-anchor" href="#_1-2-demux" aria-label="Permalink to &quot;1:2 DEMUX&quot;">​</a></h3><p>A 1-to-2 demultiplexer consists of one input line, two output lines and one select line. The signal on the select line helps to switch the input to one of the two outputs. When the select input is LOW, then the input will be passed to Y0 and if the select input is HIGH, then the input will be passed to Y1<br> Y0 = S’ D<br> Y1 = S D</p><p><img src="'+T+'" alt="img"><img src="'+E+'" alt="img"></p><h2 id="parity-generator" tabindex="-1">PARITY GENERATOR <a class="header-anchor" href="#parity-generator" aria-label="Permalink to &quot;PARITY GENERATOR&quot;">​</a></h2><p>Many systems use a parity bit as a means for bit error detection. Any group of bits contains either an even or an odd number of 1s. A parity bit is attached to a group of bits to make the total number of 1s in a group always even or always odd. An even parity bit makes the total number of 1s even, and an odd parity bit makes the total odd. A parity bit provides for the detection of a single bit error (or any odd number of errors, which is very unlikely) but cannot check for two errors in one group. For instance, let’s assume that we wish to transmit the BCD code 0101. (Parity can be used with any number of bits; we are using four for illustration.) The total code transmitted, including the even parity bit, is</p><p><img src="'+v+'" alt="img"></p><p>Now let’s assume that an error occurs in the third bit from the left (the 1 becomes a 0)</p><p><img src="'+q+'" alt="img"></p><p>When this code is received, the parity check circuitry determines that there is only a single 1 (odd number), when there should be an even number of 1s. Because an even number of 1s does not appear in the code when it is received, an error is indicated.</p><h2 id="code-converter" tabindex="-1">CODE CONVERTER <a class="header-anchor" href="#code-converter" aria-label="Permalink to &quot;CODE CONVERTER&quot;">​</a></h2><h3 id="bcd-to-binary-code-converter" tabindex="-1">BCD to Binary Code converter <a class="header-anchor" href="#bcd-to-binary-code-converter" aria-label="Permalink to &quot;BCD to Binary Code converter&quot;">​</a></h3><p>The binary numbers representing the weights of the BCD bits are summed to produce the total binary number. The binary equivalent of each BCD bit is a binary number representing the weight of that bit within the total BCD number.</p><h3 id="binary-to-gray" tabindex="-1">Binary to Gray <a class="header-anchor" href="#binary-to-gray" aria-label="Permalink to &quot;Binary to Gray&quot;">​</a></h3><p>Conversion between binary code and Gray code is sometimes useful. The following rules explain how to convert from a binary number to a Gray code word:</p><ol><li>The most significant bit (left-most) in the Gray code is the same as the corresponding MSB in the binary number.</li><li>Going from left to right, add each adjacent pair of binary code bits to get the next Gray code bit. Discard carries</li></ol><p><img src="'+A+'" alt="img"><img src="'+R+'" alt="img"></p><h3 id="gray-to-binary" tabindex="-1">Gray to Binary <a class="header-anchor" href="#gray-to-binary" aria-label="Permalink to &quot;Gray to Binary&quot;">​</a></h3><p>To convert from Gray code to binary, use a similar method; however, there are some differences. The following rules apply:</p><ol><li>The most significant bit (left-most) in the binary code is the same as the corresponding bit in the Gray code.</li><li>Add each binary code bit generated to the Gray code bit in the next adjacent position. Discard carries.</li></ol><p><img src="'+C+'" alt="img"><img src="'+I+'" alt="img"></p><h2 id="comparators" tabindex="-1">COMPARATORS <a class="header-anchor" href="#comparators" aria-label="Permalink to &quot;COMPARATORS&quot;">​</a></h2><p>The exclusive-NOR gate can be used as a basic comparator because its output is a 0 if the two input bits are not equal and a 1 if the input bits are equal. The basic comparator can be expanded to any number of bits. The AND gate sets the condition that all corresponding bits of the two numbers must be equal if the two numbers themselves are equal. To determine an inequality of binary numbers A and B, you first examine the highest order bit in each number. The following conditions are possible: 1. If A3 = 1 and B3 = 0, number A is greater than number B. 2. If A3 = 0 and B3 = 1, number A is less than number B. 3. If A3 = B3, then you must examine the next lower bit position for an inequality. These three operations are valid for each bit position in the numbers. The general procedure used in a comparator is to check for an inequality in a bit position, starting with the highest-order bits (MSBs). When such an inequality is found, the relationship of the two numbers is established, and any other inequalities in lower-order bit positions must be ignored because it is possible for an opposite indication to occur; the highest-order indication must take precedence.</p><p><img src="'+_+'" alt="img"></p><h2 id="registers" tabindex="-1">Registers <a class="header-anchor" href="#registers" aria-label="Permalink to &quot;Registers&quot;">​</a></h2><p>A register is a group of flip‐flops, each one of which shares a common clock and is capable of storing one bit of information. An n ‐bit register consists of a group of n flip‐flops capable of storing n bits of binary information. In addition to the flip‐flops, a register may have combinational gates that perform certain data‐processing tasks.</p><h3 id="four‐bit-register" tabindex="-1">Four‐bit register <a class="header-anchor" href="#four‐bit-register" aria-label="Permalink to &quot;Four‐bit register&quot;">​</a></h3><p>The common clock input triggers all flip‐flops on the positive edge of each pulse, and the binary data available at the four inputs are transferred into the register. The value of (I3 , I2 , I1 , I0) immediately before the clock edge determines the value of (A3 , A2 , A1 , A0) after the clock edge. The four outputs can be sampled at any time to obtain the binary information stored in the register. The input Clear_b goes to the active‐low R (reset) input of all four flip‐flops. When this input goes to 0, all flip‐flops are reset asynchronously. The Clear_b input is useful for clearing the register to all 0’s prior to its clocked operation. The R inputs must be maintained at logic 1 (i.e., de-asserted) during normal clocked operation. Note that, depending on the flip‐flop, either Clear, Clear_b, reset, or reset_b can be used to indicate the transfer of the register to an all 0’s state.</p><p><img src="'+D+'" alt="img"></p><h3 id="four-bit-register-with-parallel-load-gi-ai-and-bi" tabindex="-1">Four bit register with parallel load**Gi = Ai AND Bi ** <a class="header-anchor" href="#four-bit-register-with-parallel-load-gi-ai-and-bi" aria-label="Permalink to &quot;Four bit register with parallel load**Gi = Ai AND Bi  **&quot;">​</a></h3><p>A four‐bit data‐storage register with a load control input that is directed through gates and into the D inputs of the flip‐flops. The additional gates implement a two‐channel mux whose output drives the input to the register with either the data bus or the output of the register. The load input to the register determines the action to be taken with each clock pulse.</p><p><img src="'+P+'" alt="img"></p><h3 id="shift-registers" tabindex="-1">SHIFT REGISTERS <a class="header-anchor" href="#shift-registers" aria-label="Permalink to &quot;SHIFT REGISTERS&quot;">​</a></h3><h4 id="serial-in-serial-out-registers" tabindex="-1">SERIAL IN/SERIAL OUT REGISTERS <a class="header-anchor" href="#serial-in-serial-out-registers" aria-label="Permalink to &quot;SERIAL IN/SERIAL OUT REGISTERS&quot;">​</a></h4><p>The serial in/serial out shift register accepts data serially—that is, one bit at a time on a single line. It produces the stored information on its output also in serial form .</p><p><img src="'+x+'" alt="img"></p><h4 id="serial-in-parallel-out-shift-registers" tabindex="-1">Serial In/Parallel Out Shift Registers <a class="header-anchor" href="#serial-in-parallel-out-shift-registers" aria-label="Permalink to &quot;Serial In/Parallel Out Shift Registers&quot;">​</a></h4><p>Data bits are entered serially (least-significant bit first) into a serial in/parallel out shift register in the same manner as in serial in/serial out registers. The difference is the way in which the data bits are taken out of the register; in the parallel output register, the output of each stage is available. Once the data is stored, each bit appears on its respective output line, and all bits are available simultaneously, rather than on a bit-by-bit basis as with the serial output.</p><p><img src="'+O+'" alt="img"></p><h4 id="parallel-in-serial-out-shift-registers" tabindex="-1">Parallel In/Serial Out Shift Registers <a class="header-anchor" href="#parallel-in-serial-out-shift-registers" aria-label="Permalink to &quot;Parallel In/Serial Out Shift Registers&quot;">​</a></h4><p>For a register with parallel data inputs, the bits are entered simultaneously into their respective stages on parallel lines rather than on a bit-by-bit basis on one line as with serial data inputs.</p><p><img src="'+S+'" alt="img"></p><h4 id="parallel-in-parallel-out-shift-registers" tabindex="-1">Parallel In/Parallel Out Shift Registers <a class="header-anchor" href="#parallel-in-parallel-out-shift-registers" aria-label="Permalink to &quot;Parallel In/Parallel Out Shift Registers&quot;">​</a></h4><p>Parallel entry and parallel output of data have been discussed. The parallel in/parallel out register employs both methods. Immediately following the simultaneous entry of all data bits, the bits appear on the parallel outputs.</p><p><img src="'+L+'" alt="img"></p><h2 id="counters" tabindex="-1">COUNTERS <a class="header-anchor" href="#counters" aria-label="Permalink to &quot;COUNTERS&quot;">​</a></h2><p>A register that goes through a prescribed sequence of states upon the application of input pulses is called a counter. The input pulses may be clock pulses, or they may originate from some external source and may occur at a fixed interval of time or at random. The sequence of states may follow the binary number sequence or any other sequence of states.</p><h3 id="binary-ripple-counter" tabindex="-1">BINARY RIPPLE COUNTER <a class="header-anchor" href="#binary-ripple-counter" aria-label="Permalink to &quot;BINARY RIPPLE COUNTER&quot;">​</a></h3><p>A binary ripple counter consists of a series connection of complementing flip‐flops, with the output of each flip‐flop connected to the C input of the next higher order flip‐flop. The flip‐flop holding the least significant bit receives the incoming count pulses. A complementing flip‐flop can be obtained from a JK flip‐flop with the J and K inputs tied together or from a T flip‐flop. A third possibility is to use a D flip‐flop with the complement output connected to the D input.The output of each flip‐flop is connected to the C input of the next flip‐flop in sequence. The flip‐flop holding the least significant bit receives the incoming count pulses. The bubble in front of the dynamic indicator symbol next to C indicates that the flip‐flops respond to the negative‐edge transition of the input. The negative transition occurs when the output of the previous flip‐flop to which C is connected goes from 1 to 0.</p><p><img src="'+B+'" alt="img"></p><h3 id="bcd-ripple-counter" tabindex="-1">BCD RIPPLE COUNTER <a class="header-anchor" href="#bcd-ripple-counter" aria-label="Permalink to &quot;BCD RIPPLE COUNTER&quot;">​</a></h3><p>A decimal counter follows a sequence of 10 states and returns to 0 after the count of 9. Such a counter must have at least four flip‐flops to represent each decimal digit, since a decimal digit is represented by a binary code with at least four bits. The sequence of states in a decimal counter is dictated by the binary code used to represent a decimal digit. The four outputs are designated by the letter symbol Q, with a numeric subscript equal to the binary weight of the corresponding bit in the BCD code. Note that the output of Q1 is applied to the C inputs of both Q2 and Q8 and the output of Q2 is applied to the C input of Q4. The J and K inputs are connected either to a permanent 1 signal or to outputs of other flip‐flops.</p><p><img src="'+N+'" alt="img"></p><h3 id="_4-bit-synchronous-binary-counter" tabindex="-1">4 BIT SYNCHRONOUS BINARY COUNTER <a class="header-anchor" href="#_4-bit-synchronous-binary-counter" aria-label="Permalink to &quot;4 BIT SYNCHRONOUS BINARY COUNTER&quot;">​</a></h3><p>The flip‐flop in the least significant position is complemented with every pulse. A flip‐flop in any other position is complemented when all the bits in the lower significant positions are equal to 1 . Synchronous binary counters have a regular pattern and can be constructed with complementing flip‐flops and gates. The C inputs of all flip‐flops are connected to a common clock. The counter is enabled by Count_enable. If the enable input is 0, all J and K inputs are equal to 0 and the clock does not change the state of the counter. The first stage, A0, has its J and K equal to 1 if the counter is enabled. The other J and K inputs are equal to 1 if all previous least significant stages are equal to 1 and the count is enabled. The chain of AND gates generates the required logic for the J and K inputs in each stage. The counter can be extended to any number of stages, with each stage having an additional flip‐flop and an AND gate that gives an output of 1 if all previous flip‐flop outputs are 1. Note that the flip‐flops trigger on the positive edge of the clock.</p><p><img src="'+F+'" alt="img"></p><h3 id="four-bit-up-down-binary-counter" tabindex="-1">FOUR BIT UP-DOWN BINARY COUNTER <a class="header-anchor" href="#four-bit-up-down-binary-counter" aria-label="Permalink to &quot;FOUR BIT UP-DOWN BINARY COUNTER&quot;">​</a></h3><p>The two operations can be combined in one circuit to form a counter capable of counting either up or down. It has an up control input and a down control input. When the up input is 1, the circuit counts up, since the T inputs receive their signals from the values of the previous normal outputs of the flip‐flops.</p><p><img src="'+U+'" alt="img"></p><h3 id="binary-counter-with-parallel-load" tabindex="-1">BINARY COUNTER WITH PARALLEL LOAD <a class="header-anchor" href="#binary-counter-with-parallel-load" aria-label="Permalink to &quot;BINARY COUNTER WITH PARALLEL LOAD&quot;">​</a></h3><p>When equal to 1, the input load control disables the count operation and causes a transfer of data from the four data inputs into the four flip‐flops. If both control inputs are 0, clock pulses do not change the state of the register. The carry output becomes a 1 if all the flip‐flops are equal to 1 while the count input is enabled. This is the condition for complementing the flip‐flop that holds the next significant bit. The carry output is useful for expanding the counter to more than four bits. The speed of the counter is increased when the carry is generated directly from the outputs of all four flip‐flops, because the delay to generate the carry bit is reduced. A counter with a parallel load can be used to generate any desired count sequence.the Count control is set to 1 to enable the count through the CLK input. Also, recall that the Load control inhibits the count and that the clear operation is independent of other control inputs.</p><p><img src="'+H+'" alt="img"> []&quot;(Intro/image-0120.png)</p><h2 id="arithmetic-logic-unit-alu" tabindex="-1">ARITHMETIC LOGIC UNIT (ALU) <a class="header-anchor" href="#arithmetic-logic-unit-alu" aria-label="Permalink to &quot;ARITHMETIC LOGIC UNIT (ALU)&quot;">​</a></h2><p>The ALU, or arithmetic logic unit, is a crucial component of the CPU (central processing unit) in a computer system. It is responsible for carrying out arithmetic and logic operations. Also referred to as the integer unit (IU), it is an integrated circuit found in both CPUs and GPUs. The ALU is the final stage in the processor where calculations are performed. It possesses the capability to handle various tasks related to arithmetic and logic operations, including addition, subtraction, shifting operations, as well as Boolean comparisons such as XOR, OR, AND, and NOT operations. It operates on binary numbers and can execute mathematical and bitwise operations. The ALU consists of two units: the arithmetic unit (AU) and the logic unit (LU). By utilizing operands and codes, the ALU determines which operations to perform based on the input data provided. Once the ALU completes processing the input, the resulting information is sent to the computer&#39;s memory.</p><p>Here are the main functions of an ALU:</p><p><strong>Arithmetic Operations</strong>: The ALU performs various arithmetic operations on binary numbers, such as addition, subtraction, multiplication, and division. It uses binary addition and subtraction circuits to handle these operations efficiently.</p><p><strong>Logical Operations</strong>: The ALU executes logical operations on binary data, including AND, OR, XOR (exclusive OR), and NOT. These operations manipulate individual bits or binary values to determine logical relationships and produce logical results.</p><p><strong>Comparison Operations</strong>: The ALU performs comparison operations to determine the relationship between two binary values. It can compare if two values are equal, not equal, greater than, less than, greater than or equal to, or less than or equal to each other. The result of these comparisons is typically represented by setting specific flags or registers in the CPU.</p><p><strong>Bitwise Operations</strong>: The ALU carries out bitwise operations, which manipulate individual bits in binary numbers. These operations include shifting the bits left or right, rotating bits, and masking operations. Bitwise operations are commonly used in tasks such as data manipulation, encryption, and signal processing.</p><p><strong>Conditional Operations</strong>: The ALU supports conditional operations, enabling the CPU to execute different instructions based on certain conditions. For example, it can perform conditional branching, where the CPU jumps to a specific instruction address based on the result of a comparison operation.</p><p><strong>Data Movement</strong>: The ALU may also handle data movement operations within the CPU. This involves transferring data between registers, memory, and other CPU components.</p><h2 id="encoder" tabindex="-1">ENCODER <a class="header-anchor" href="#encoder" aria-label="Permalink to &quot;ENCODER&quot;">​</a></h2><p>An encoder is a digital circuit that performs the inverse operation of a decoder. An encoder has 2n (or fewer) input lines and n output lines.</p><h3 id="priority-encoder" tabindex="-1">PRIORITY ENCODER <a class="header-anchor" href="#priority-encoder" aria-label="Permalink to &quot;PRIORITY ENCODER&quot;">​</a></h3><p>A priority encoder is an encoder circuit that includes the priority function. The operation of the priority encoder is such that if two or more inputs are equal to 1 at the same time, the input having the highest priority will take precedence. In addition to the two outputs x and y , the circuit has a third output designated by V ; this is a valid bit indicator that is set to 1 when one or more inputs are equal to 1. If all inputs are 0, there is no valid input and V is equal to 0. The other two outputs are not inspected when V equals 0 and are specified as don’t-care conditions.</p><p><img src="'+G+'" alt="img"><img src="'+Y+'" alt="img"></p><p>x = D2+ D3<br> y = D3 + D1 D 2<br> V = D0 + D1 + D2 + D3</p><p>[]&quot;(Intro/image-0132.png)</p><h2 id="decoder" tabindex="-1">DECODER <a class="header-anchor" href="#decoder" aria-label="Permalink to &quot;DECODER&quot;">​</a></h2><p>A decoder is a combinational circuit that converts binary information from n input lines to a maximum of 2n unique output lines.The decoders presented here are called n -to- m -line decoders, where m … 2^n.</p><h3 id="_3-8-line-decoder" tabindex="-1">3-8 LINE DECODER <a class="header-anchor" href="#_3-8-line-decoder" aria-label="Permalink to &quot;3-8 LINE DECODER&quot;">​</a></h3><p>The three inputs are decoded into eight outputs, each representing one of the minterms of the three input variables. The three inverters provide the complement of the inputs, and each one of the eight AND gates generates one of the minterms.</p><p><img src="'+X+'" alt="img"><img src="'+M+'" alt="img"></p><h3 id="_2-4-line-decoder-with-enable-input" tabindex="-1">2-4 LINE DECODER WITH ENABLE INPUT <a class="header-anchor" href="#_2-4-line-decoder-with-enable-input" aria-label="Permalink to &quot;2-4 LINE DECODER WITH ENABLE INPUT&quot;">​</a></h3><p>The circuit operates with complemented outputs and a complement enable input. The decoder is enabled when E is equal to 0 (i.e., active-low enable). As indicated by the truth table, only one output can be equal to 0 at any given time; all other outputs are equal to 1. The output whose value is equal to 0 represents the minterm selected by inputs A and B . The circuit is disabled when E is equal to 1, regardless of the values of the other two inputs. When the circuit is disabled, none of the outputs are equal to 0 and none of the minterms are selected.</p><p><img src="'+Q+'" alt="img"><img src="'+W+'" alt="img"></p><h1 id="how-to-make-a-verilog-program" tabindex="-1">HOW TO MAKE A VERILOG PROGRAM <a class="header-anchor" href="#how-to-make-a-verilog-program" aria-label="Permalink to &quot;HOW TO MAKE A VERILOG PROGRAM&quot;">​</a></h1><p><img src="'+j+'" alt="img"></p><h3 id="create-a-new-project-in-your-own-version-of-quartus-prime" tabindex="-1">Create a New Project in your own version of Quartus Prime. <a class="header-anchor" href="#create-a-new-project-in-your-own-version-of-quartus-prime" aria-label="Permalink to &quot;Create a New Project in your own version of Quartus Prime.&quot;">​</a></h3><p><img src="'+V+'" alt="img"></p><h3 id="select-an-appropriate-directory-for-your-verilog-project-files-and-create-an-empty-project-file-template" tabindex="-1">Select an appropriate directory for your Verilog project files and create an empty project file template. <a class="header-anchor" href="#select-an-appropriate-directory-for-your-verilog-project-files-and-create-an-empty-project-file-template" aria-label="Permalink to &quot;Select an appropriate directory for your Verilog project files and create an empty project file template.&quot;">​</a></h3><p><img src="'+K+'" alt="[]&quot; src="></p><h3 id="use-the-10m50daf484c7g-board-from-the-max-10-family" tabindex="-1">Use the 10M50DAF484C7G Board from the MAX 10 Family. <a class="header-anchor" href="#use-the-10m50daf484c7g-board-from-the-max-10-family" aria-label="Permalink to &quot;Use the 10M50DAF484C7G Board from the MAX 10 Family.&quot;">​</a></h3><p><img src="'+J+'" alt="img"><img src="'+z+'" alt="img"></p><h3 id="set-modelsim-as-your-simulation-tool-modelsim-must-be-installed-prior-and-finish-the-initialization-of-the-project" tabindex="-1">Set ModelSim as your Simulation Tool (ModelSim must be installed prior) and finish the initialization of the project. <a class="header-anchor" href="#set-modelsim-as-your-simulation-tool-modelsim-must-be-installed-prior-and-finish-the-initialization-of-the-project" aria-label="Permalink to &quot;Set ModelSim as your Simulation Tool (ModelSim must be installed prior) and finish the initialization of the project.&quot;">​</a></h3><p><img src="'+Z+'" alt="img"></p><p><img src="'+$+'" alt="img"></p><h3 id="click-on-the-file-icon-in-the-top-left-corner-and-create-a-new-verilog-hdl-file" tabindex="-1">Click on the file icon in the top left corner and create a new Verilog HDL file. <a class="header-anchor" href="#click-on-the-file-icon-in-the-top-left-corner-and-create-a-new-verilog-hdl-file" aria-label="Permalink to &quot;Click on the file icon in the top left corner and create a new Verilog HDL file.&quot;">​</a></h3><p><img src="'+ee+'" alt="img"></p><h3 id="when-you-wish-to-save-your-program-simply-use-ctrl-s-or-click-the-save-icon-in-the-top-left-corner" tabindex="-1">When you wish to save your program, simply use Ctrl+S or click the Save icon in the top left corner. <a class="header-anchor" href="#when-you-wish-to-save-your-program-simply-use-ctrl-s-or-click-the-save-icon-in-the-top-left-corner" aria-label="Permalink to &quot;When you wish to save your program, simply use Ctrl+S or click the Save icon in the top left corner.&quot;">​</a></h3><p><img src="'+te+'" alt="img"><img src="'+ae+'" alt="img"></p><h3 id="before-running-your-program-you-must-first-set-a-testbench-for-it-do-this-by-going-into-the-assignments-menu-and-clicking-settings" tabindex="-1">Before running your program, you must first set a testbench for it. Do this by going into the Assignments menu and clicking Settings. <a class="header-anchor" href="#before-running-your-program-you-must-first-set-a-testbench-for-it-do-this-by-going-into-the-assignments-menu-and-clicking-settings" aria-label="Permalink to &quot;Before running your program, you must first set a testbench for it. Do this by going into the Assignments menu and clicking Settings.&quot;">​</a></h3><p><img src="'+ie+'" alt="img"></p><h3 id="change-the-nativelink-setting-to-compile-test-bench-and-select-the-test-bench-file-for-your-program" tabindex="-1">Change the NativeLink Setting to Compile Test Bench and select the Test Bench file for your program. <a class="header-anchor" href="#change-the-nativelink-setting-to-compile-test-bench-and-select-the-test-bench-file-for-your-program" aria-label="Permalink to &quot;Change the NativeLink Setting to Compile Test Bench and select the Test Bench file for your program.&quot;">​</a></h3><p><img src="'+oe+'" alt="img"></p><h3 id="create-a-new-test-bench-if-you-are-creating-one-for-a-new-program-that-has-not-been-made-before" tabindex="-1">Create a new Test Bench if you are creating one for a new program that has not been made before. <a class="header-anchor" href="#create-a-new-test-bench-if-you-are-creating-one-for-a-new-program-that-has-not-been-made-before" aria-label="Permalink to &quot;Create a new Test Bench if you are creating one for a new program that has not been made before.&quot;">​</a></h3><p><img src="'+se+'" alt="img"></p><h3 id="name-your-test-bench-appropriately-usually-just-the-name-of-the-test-bench-file-and-add-it-to-the-list-of-test-benches" tabindex="-1">Name your Test Bench appropriately (usually just the name of the test bench file) and add it to the list of Test Benches. <a class="header-anchor" href="#name-your-test-bench-appropriately-usually-just-the-name-of-the-test-bench-file-and-add-it-to-the-list-of-test-benches" aria-label="Permalink to &quot;Name your Test Bench appropriately (usually just the name of the test bench file) and add it to the list of Test Benches.&quot;">​</a></h3><h3 id="after-setting-your-testbench-you-can-now-run-and-compile-your-program-by-clicking-on-the-third-play-button" tabindex="-1">After setting your testbench, you can now run and compile your program by clicking on the third play button. <a class="header-anchor" href="#after-setting-your-testbench-you-can-now-run-and-compile-your-program-by-clicking-on-the-third-play-button" aria-label="Permalink to &quot;After setting your testbench, you can now run and compile your program by clicking on the third play button.&quot;">​</a></h3><h3 id="you-will-be-able-to-view-your-circuit-design-and-how-it-is-structured-and-simulate-results-using-the-test-bench-by-going-to-the-tools-menu" tabindex="-1">You will be able to view your circuit design and how it is structured, and simulate results using the test bench by going to the Tools menu. <a class="header-anchor" href="#you-will-be-able-to-view-your-circuit-design-and-how-it-is-structured-and-simulate-results-using-the-test-bench-by-going-to-the-tools-menu" aria-label="Permalink to &quot;You will be able to view your circuit design and how it is structured, and simulate results using the test bench by going to the Tools menu.&quot;">​</a></h3><h2 id="bibliography" tabindex="-1">BIBLIOGRAPHY <a class="header-anchor" href="#bibliography" aria-label="Permalink to &quot;BIBLIOGRAPHY&quot;">​</a></h2><ol><li>Digital Design, 5th Edition by M Morris Mano and Michael Ciletti</li><li>Digital Fundamentals by Floyd and Jain</li><li><a href="https://www.electronicshub.org/demultiplexerdemux/" target="_blank" rel="noreferrer">electronicshub.org/demultiplexerdemux</a></li><li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_flip_flops.htm" target="_blank" rel="noreferrer">tutorialspoint.com/digital_circuits/digital_circuits_flip_flops</a></li><li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_demultiplexers.htm" target="_blank" rel="noreferrer">tutorialspoint.com/digital_circuits/digital_circuits_demultiplexers</a></li></ol>',232),ce=[de];function ue(me,fe,ge,be,ye,ke){return le(),ne("div",null,ce)}const ve=re(pe,[["render",ue]]);export{Ee as __pageData,ve as default};
